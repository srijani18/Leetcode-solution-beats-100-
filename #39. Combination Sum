## ğŸ§© Problem: Combination Sum

Given an array of distinct integers `candidates` and a target integer `target`, return a list of all unique combinations of `candidates` where the chosen numbers sum to `target`.  
You may use the same number from `candidates` an unlimited number of times.  
The combinations may be returned in any order.

---
##Solution By Srijani Guha Ray
### ğŸ’¡ Intuition

We explore all possible combinations of elements that can sum up to the target.  
At each step, we have two choices for the current index:
1. **Include** the current element and stay on the same index (since elements can be reused).
2. **Exclude** the current element and move to the next index.

We use recursion and backtracking to explore all possible sums.  
When the running sum equals the target, we add the current combination to the result.

---

### ğŸ§  Approach

1. Start recursion from index `0` with an empty combination and `sum = 0`.
2. If `sum == target`, store the combination in the answer list.
3. If `sum > target` or `i == candidates.size()`, stop exploring that path.
4. Otherwise:
   - Include `candidates[i]` and recurse with the same index (`i`).
   - Exclude it and recurse with the next index (`i + 1`).
5. Use backtracking to undo the last choice before moving to the next branch.

---

### â±ï¸ Time Complexity

**O(2^t)** â€” where `t` is the target divided by the smallest element in `candidates`.  
Each number can either be included multiple times or excluded, leading to exponential possibilities.

---

### ğŸ’¾ Space Complexity

**O(t)** â€” due to recursion stack and temporary storage of combinations.

---

### âœ… Code

```cpp
class Solution {
public:
    void combination(vector<vector<int>>& ans, vector<int>& res, vector<int>& candidates, int target, int i, int& sum) {
        if (i == candidates.size() || sum > target) return;

        if (sum == target) {
            ans.push_back(res);
            return;
        }

        sum += candidates[i];
        res.push_back(candidates[i]);
        combination(ans, res, candidates, target, i, sum);
        sum -= candidates[i];
        res.pop_back();
        combination(ans, res, candidates, target, i + 1, sum);
    }

    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        vector<vector<int>> ans;
        vector<int> res;
        int sum = 0;
        combination(ans, res, candidates, target, 0, sum);
        return ans;
    }
};
