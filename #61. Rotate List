# Rotate List â€” C++ Solution

**Problem:** :Given the head of a linked list, rotate the list to the right by k places.  
**Author:** Srijani Guha Ray  

---

## Intuition
Rotating a linked list by `k` positions to the right is similar to taking the last `k` nodes and moving them to the front.  

Key ideas:  
- The rotation is periodic with the list length, so rotating by `k` and `k % length` gives the same result.  
- Turning the list into a circular linked list (temporarily) simplifies finding the new head and breaking the circle at the right place.

---

## Approach
1. **Handle Edge Cases**  
   - If the list is empty or has only one node, or `k` is `0` or a multiple of the list length, return the original list.

2. **Count the Nodes**  
   - Traverse the list to count its length (`count`) and keep track of the last node (`listend`).

3. **Adjust k**  
   - Reduce unnecessary rotations by using `k = k % count`.  
   - If `k % count == 0`, no rotation is needed.

4. **Find the New Tail**  
   - The new tail is the `(count - k)`-th node (1-indexed) from the start.  
   - Traverse again to stop at `(count - k)` and split the list.

5. **Reconnect**  
   - The node after the new tail becomes the new head.  
   - Connect the original tail (`listend`) to the old head to complete the rotation.  
   - Break the link at the new tail to restore a singly linked list.

---

## Complexity
- **Time Complexity:** `O(n)`  
  - We traverse the list twice: once to count nodes and once to find the split point.  
- **Space Complexity:** `O(1)`  
  - The rotation is done in-place using only a few extra pointers.

---

## Code
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        if (!head || !head->next || k == 0) return head;

        // Count the nodes
        int count = 1;
        ListNode* temp = head;
        while (temp->next) {
            count++;
            temp = temp->next;
        }
        ListNode* listend = temp; // Last node

        // Adjust k
        k = k % count;
        if (k == 0) return head;

        // Find the new tail
        ListNode* dummy = new ListNode(0, head);
        temp = dummy;
        for (int i = 0; i < count - k; i++) {
            temp = temp->next;
        }

        // Reconnect
        ListNode* nxt = temp->next; // New head
        temp->next = nullptr;
        listend->next = head;

        return nxt;
    }
};
