Problem Statement:
A peak element in a 2D grid is an element that is strictly greater than all of its adjacent neighbors to the left, right, top, and bottom.

Given a 0-indexed m x n matrix mat where no two adjacent cells are equal, find any peak element mat[i][j] and return the length 2 array [i,j].

You may assume that the entire matrix is surrounded by an outer perimeter with the value -1 in each cell.

You must write an algorithm that runs in O(m log(n)) or O(n log(m)) time.


# Solution by Srijani Guha Ray

Intuition
By choosing the maximum element in the current column, we ensure:

If it’s greater than both left and right neighbors → it’s a peak (since top/bottom neighbors can’t be larger by construction of max).

If it’s smaller than one side, then a larger element exists in that direction, so the peak must lie in that half.

This works exactly like 1D peak finding but extended to 2D by collapsing rows and searching along columns.

Approach
Binary search on columns

Maintain two pointers: low = 0, high = n-1 (where n = number of columns).
Repeatedly pick a middle column mid.
Find max element in that column

Scan all rows in column mid to find the row index r where the element is maximum.
This ensures you’re considering the “best candidate” in that column.
Check neighbors (left & right columns)

Compare mat[r][mid] with its immediate neighbors:

left = mat[r][mid-1] if exists, else -1 (perimeter assumption).

right = mat[r][mid+1] if exists, else -1.

Decide search direction

If mat[r][mid] > left and mat[r][mid] > right → we found a peak.

Else if left > mat[r][mid] → peak lies somewhere in the left half → move high = mid - 1.

Else → peak lies in the right half → move low = mid + 1.

Continue until you find the peak. The problem guarantees at least one peak exists, so the loop always terminates.

Complexity
Time complexity:
O(m log n)

Space complexity:
O(1)

Code
class Solution {
public:
    vector<int> findPeakGrid(vector<vector<int>>& mat) {
        
        int m=mat.size();
        int n=mat[0].size();
        int low= 0;
        int high=n-1;
        while(low<=high)
        {
            int mid=low+(high-low)/2;
            int maxele=INT_MIN;
            int r=0;
            //int l=0;
            for(int i=0;i<m;i++)
            {
                if(mat[i][mid]>maxele)
                {
                    r=i;
                    maxele=mat[i][mid];
                }
            }

            int left= (mid-1>=0)? mat[r][mid-1]:-1;
            int right=(mid+1<n) ? mat[r][mid+1]:-1;

            if(mat[r][mid]>left && mat[r][mid]>right)
             return {r, mid};
            else if(mat[r][mid]<right)
                low=mid+1;
            else
             high=mid-1;

        }

        return {-1,-1};
    }
};
