# ğŸ”¢ Combination Sum II (LeetCode #40)

## ğŸ§© Problem Statement
Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.

Each number in candidates may only be used once in the combination.

Note: The solution set must not contain duplicate combinations.

Example 1:

Input: candidates = [10,1,2,7,6,1,5], target = 8
Output: 
[
[1,1,6],
[1,2,5],
[1,7],
[2,6]
]
Example 2:

Input: candidates = [2,5,2,1,2], target = 5
Output: 
[
[1,2,2],
[5]
]
 

#Solution By Srijani Guha Ray
---

## ğŸ§  Intuition
We want to explore all possible combinations of numbers that sum to the target.  
Since each number can be used only once and duplicates are present, we need a way to:
- **Avoid reusing** the same element in the same combination.
- **Skip duplicate values** efficiently.

Sorting the array allows us to detect and skip duplicates during recursion.

---

## âš™ï¸ Approach
1. **Sort** the array to handle duplicates easily.  
2. Use **backtracking** to explore combinations:
   - Keep track of the current combination (`res`) and the current sum.
   - Recur for each number starting from the current index.
3. **Prune branches** where the sum exceeds the target.  
4. **Skip duplicates** at the same recursion depth using:
   ```cpp
   if (i > start && candidates[i] == candidates[i - 1]) continue;


Time Complexity
O(2^n) in the worst case due to recursion.
O(n log n) for sorting the array.
Actual runtime is reduced due to pruning and duplicate skipping.

Space Complexity
O(n) for recursion stack and temporary combination vector.
O(k) for storing all valid combinations in the result list.

ğŸ§© Key Takeaways
Sort before backtracking to handle duplicates efficiently.
Skip duplicate elements only when i > start.
Backtracking with pruning ensures efficiency.


class Solution {
public:
    void combination(vector<int>& candidates, int target, int n, int start, vector<int>& res, int sum, vector<vector<int>>& ans) {
        if(sum > target) return;
        if(sum == target) {
            ans.push_back(res);
            return;
        }

        for(int i = start; i < n; i++) {
            if(i > start && candidates[i] == candidates[i-1]) continue;

            res.push_back(candidates[i]);
            combination(candidates, target, n, i + 1, res, sum + candidates[i], ans);
            res.pop_back();
        }
    }

    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        vector<vector<int>> ans;
        vector<int> res;
        sort(candidates.begin(), candidates.end());
        combination(candidates, target, candidates.size(), 0, res, 0, ans);
        return ans;
    }
};
