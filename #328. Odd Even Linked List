Problem Statement:
Given the head of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return the reordered list.

The first node is considered odd, and the second node is even, and so on.

Note that the relative order inside both the even and odd groups should remain as it was in the input.

You must solve the problem in O(1) extra space complexity and O(n) time complexity.

 

#solution by Srijani Guha Ray
Intuition
We want to group all nodes at odd indices together first, followed by all nodes at even indices.

Instead of creating new lists or copying values, we can rearrange the pointers in-place:

Odd nodes: 1st, 3rd, 5th…

Even nodes: 2nd, 4th, 6th…

By walking through the list once, we can detach even nodes into their own chain, then connect the odd list’s tail to the even list’s head.

Approach
Edge case: If the list has fewer than 3 nodes (head == NULL || head->next == NULL), return head as it’s already grouped.

Initialize pointers:

odd = head → points to the first node.

even = head->next → points to the second node.

evenHead = even → store even’s head to reconnect later.

Re-link nodes:

While even and even->next are not NULL:

Link odd->next to even->next (the next odd node).

Advance odd to odd->next.

Link even->next to odd->next (the next even node).

Advance even to even->next.

Connect lists: Attach the even list at the end: odd->next = evenHead.

Return head.

Complexity
Time complexity:
O(n)

Space complexity:
O(1)

Code
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* oddEvenList(ListNode* head) {

       if (!head || !head->next) return head;

        ListNode* odd = head;
        ListNode* even = head->next;
        ListNode* evenHead = even;  // store start of even list

        while (even && even->next) {
            odd->next = even->next;  // link odd to next odd
            odd = odd->next;

            even->next = odd->next;  // link even to next even
            even = even->next;
        }

        odd->next = evenHead; // attach even list after odd list
        return head;
    }
};
