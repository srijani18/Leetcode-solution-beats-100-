# ðŸŽ¯ LeetCode 216 â€” Combination Sum III

## ðŸ” Problem Statement
Find all valid combinations of `k` numbers that sum up to `n`,  
such that only numbers from `1` to `9` can be used,  
and each number can be used **at most once**.

Return the list of all possible valid combinations.  
The combinations can be returned in **any order**.


#Solution by Srijani Guha Ray
---

### Example 1
**Input:**  
`k = 3, n = 7`  

**Output:**  
`[[1,2,4]]`

---

### Example 2
**Input:**  
`k = 3, n = 9`  

**Output:**  
`[[1,2,6], [1,3,5], [2,3,4]]`

---

## ðŸ’¡ Intuition
We are asked to find all unique combinations of `k` distinct numbers between `1` and `9` whose sum equals `n`.  

The key insights are:
- Each number can be chosen **at most once**, so we must move forward each time (no repetition).
- We can use **backtracking** to explore all possible combinations.
- To optimize, we stop exploring when:
  - The running sum exceeds `n`, or  
  - The current combination size exceeds `k`.

---

## ðŸ§  Approach
1. Use a **recursive backtracking** function `comb()`:
   - Maintain:
     - `arr`: the current combination being built.
     - `sum`: the current sum of elements.
     - `start`: the starting number for the next candidate.
   - When `sum == n` **and** `arr.size() == k`, store the valid combination.
2. Iterate numbers from `start` to `9`:
   - Add the current number to `arr`.
   - Recurse with updated parameters:
     - `start = i + 1`
     - `sum = sum + i`
   - Backtrack by removing the last added number.
3. Add pruning:
   - If `arr.size() > k`, stop exploring further (no need to go deeper).

---

## ðŸ§© Code
```cpp
class Solution {
public:
    void comb(vector<vector<int>> &res, vector<int> &arr, int n, int k, int start, int sum)
    {
        if(arr.size() > k)
            return;

        if(sum == n && arr.size() == k)
        {
            res.push_back(arr);
            return;
        }

        for(int i = start; i <= 9; i++)
        {
            arr.push_back(i);
            comb(res, arr, n, k, i + 1, sum + i);
            arr.pop_back();
        }
    }

    vector<vector<int>> combinationSum3(int k, int n) {
        vector<vector<int>> res;
        vector<int> arr;
        comb(res, arr, n, k, 1, 0);
        return res;
    }
};
