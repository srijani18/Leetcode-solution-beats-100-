Problem Statement:
#153. Find Minimum in Rotated Sorted Array

Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:

[4,5,6,7,0,1,2] if it was rotated 4 times.
[0,1,2,4,5,6,7] if it was rotated 7 times.
Notice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].

Given the sorted rotated array nums of unique elements, return the minimum element of this array.

You must write an algorithm that runs in O(log n) time.

Intuition
A rotated sorted array is two sorted halves.

The minimum element is the "pivot point" where rotation happens.

Using binary search, we can determine which half is sorted and move toward the unsorted half (where the minimum must lie).



# Solution by Srijani Guha Ray
Approach
Initialize

mini = INT_MAX;
low = 0, high = n-1;

Binary Search Loop (while(low <= high))

Compute mid.

Case 1: Left half is sorted (nums[mid] >= nums[low])

Then the minimum of this half is at nums[low].

Update mini = min(mini, nums[low]).

Move right â†’ low = mid + 1.

Case 2: Right half is sorted (nums[mid] < nums[low])

Then the minimum must be in this half, starting at nums[mid].

Update mini = min(mini, nums[mid]).

Move left â†’ high = mid - 1.

Return answer â†’ mini.

ðŸ§  Key Insight

The sorted half always contains a "safe" minimum at its starting index (nums[low]).

The unsorted half must contain the rotation point (and hence the true minimum).

By eliminating one half each step, we get O(log n) complexity.

âœ… Example Walkthrough

nums = [4,5,6,7,0,1,2]

mid = 3 â†’ left sorted â†’ mini = min(INT_MAX, 4) = 4 â†’ search right

mid = 5 â†’ left sorted â†’ mini = min(4, 0) = 0 â†’ search right

Eventually, answer = 0.

ðŸ‘‰ In short:
This solution finds the minimum by using binary search to repeatedly check which half of the array is sorted, updating the minimum accordingly, and discarding the sorted half since the pivot (minimum) must lie in the unsorted part.

Complexity
Time complexity:
O(log n)

Space complexity:
O(1)
class Solution {
public:
    int findMin(vector<int>& nums) {
        

        int mini=INT_MAX;
        int low=0;
        int high=nums.size()-1;
        while(low<=high)
        {
            int mid=low+(high-low)/2; 
            if(nums[mid]>=nums[low])  //if left is sorted
            {
                mini=min(mini, nums[low]);
                low=mid+1;
            }
            else{   //if right is sorted
                mini=min(mini, nums[mid]);
                high=mid-1;
            }
        }
        return mini;
    }
};
